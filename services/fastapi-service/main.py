import os
import time
import logging
from datetime import datetime
from typing import Dict, Any, Optional

from fastapi import FastAPI, HTTPException, Header, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
import uvicorn

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="VoltAgent FastAPI Service",
    description="FastAPI backend service for VoltAgent demo",
    version="1.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models
class CompletionRequest(BaseModel):
    prompt: str = Field(..., description="The input prompt for completion")
    max_tokens: Optional[int] = Field(100, description="Maximum tokens to generate")
    temperature: Optional[float] = Field(0.7, description="Sampling temperature")

class CompletionResponse(BaseModel):
    completion: str = Field(..., description="The generated completion")
    usage: Dict[str, int] = Field(..., description="Token usage statistics")
    model: str = Field(..., description="Model used for completion")
    timestamp: str = Field(..., description="Timestamp of completion")

class PingResponse(BaseModel):
    status: str = Field(..., description="Service status")

# Middleware for request logging
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    
    # Log request
    logger.info(f"Request: {request.method} {request.url}")
    
    response = await call_next(request)
    
    # Log response
    process_time = time.time() - start_time
    logger.info(f"Response: {response.status_code} - {process_time:.3f}s")
    
    return response

# API Key validation
def validate_api_key(x_api_key: Optional[str] = Header(None)) -> str:
    """Validate API key from header"""
    expected_api_key = os.getenv("API_KEY")
    
    if not expected_api_key:
        logger.error("API_KEY environment variable not set")
        raise HTTPException(status_code=500, detail="Service not configured")
    
    if not x_api_key:
        logger.warning("Missing X-API-Key header")
        raise HTTPException(status_code=401, detail="Missing API key")
    
    if x_api_key != expected_api_key:
        logger.warning(f"Invalid API key provided: {x_api_key[:8]}...")
        raise HTTPException(status_code=401, detail="Invalid API key")
    
    return x_api_key

# Routes
@app.get("/ping", response_model=PingResponse)
async def ping():
    """Health check endpoint"""
    return PingResponse(status="alive")

@app.post("/completions", response_model=CompletionResponse)
async def completions(
    request: CompletionRequest,
    api_key: str = Header(..., alias="X-API-Key")
):
    """Generate text completion"""
    # Validate API key
    validate_api_key(api_key)
    
    logger.info(f"Completions request: {request.prompt[:100]}...")
    
    try:
        # Simulate AI completion processing
        # In a real implementation, this would call an AI model
        await asyncio.sleep(0.1)  # Simulate processing time
        
        # Generate a simple completion based on the prompt
        completion_text = f"AI Response to: '{request.prompt}'\n\nThis is a simulated completion generated by the VoltAgent FastAPI service. The input was processed with max_tokens={request.max_tokens} and temperature={request.temperature}."
        
        # Calculate token usage (rough estimation)
        prompt_tokens = len(request.prompt.split())
        completion_tokens = len(completion_text.split())
        total_tokens = prompt_tokens + completion_tokens
        
        response = CompletionResponse(
            completion=completion_text,
            usage={
                "prompt_tokens": prompt_tokens,
                "completion_tokens": completion_tokens,
                "total_tokens": total_tokens
            },
            model="voltagent-demo-model-v1",
            timestamp=datetime.utcnow().isoformat()
        )
        
        logger.info(f"Completions response generated: {total_tokens} tokens")
        return response
        
    except Exception as e:
        logger.error(f"Error generating completion: {str(e)}")
        raise HTTPException(status_code=500, detail="Error generating completion")

@app.get("/health")
async def health():
    """Detailed health check"""
    return {
        "status": "ok",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "1.0.0",
        "environment": os.getenv("ENVIRONMENT", "development"),
        "uptime": time.time() - start_time
    }

# Global exception handler
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled exception: {str(exc)}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"}
    )

# Store start time for uptime calculation
start_time = time.time()

# Import asyncio for async sleep
import asyncio

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=os.getenv("ENVIRONMENT") == "development"
    )
